namespace MemberAccessorGenerator.SourceGenerator;

using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public sealed class MemberAccessorGenerator : IIncrementalGenerator
{
    // ------------------------------------------------------------
    // Generator
    // ------------------------------------------------------------

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => IsTargetSyntax(node),
                static (context, _) => GetTargetSyntax(context))
            .SelectMany(static (x, _) => x is not null ? ImmutableArray.Create(x) : [])
            .Collect();

        var providers = compilationProvider.Combine(classes);

        context.RegisterImplementationSourceOutput(
            providers,
            static (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static bool IsTargetSyntax(SyntaxNode node) =>
        node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private static ClassDeclarationSyntax? GetTargetSyntax(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not ITypeSymbol typeSymbol)
        {
            return null;
        }

        var hasAttribute = typeSymbol.GetAttributes()
            .Any(static x => x.AttributeClass!.ToDisplayString() == "MemberAccessorGenerator.GenerateAccessorAttribute" &&
                             x.ConstructorArguments.Length == 0);
        if (!hasAttribute)
        {
            return null;
        }

        return classDeclarationSyntax;
    }

    // ------------------------------------------------------------
    // Builder
    // ------------------------------------------------------------

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes)
    {
        var filename = new StringBuilder();
        var source = new StringBuilder();

        foreach (var classDeclarationSyntax in classes)
        {
            // Check cancel
            context.CancellationToken.ThrowIfCancellationRequested();

            // Build metadata
            var classSemantic = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            var classSymbol = (ITypeSymbol)classSemantic.GetDeclaredSymbol(classDeclarationSyntax)!;

            var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            // Source
            source.AppendLine("// <auto-generated />");
            source.AppendLine("#nullable disable");

            // namespace
            if (!String.IsNullOrEmpty(ns))
            {
                source.Append("namespace ").Append(ns).AppendLine();
            }

            source.AppendLine("{");

            // TODO

            source.AppendLine("}");

            // Write
            context.AddSource(
                MakeRegistryFilename(filename, ns, className),
                SourceText.From(source.ToString(), Encoding.UTF8));

            source.Clear();
        }
    }

    private static string MakeRegistryFilename(StringBuilder buffer, string ns, string className)
    {
        buffer.Clear();

        if (!String.IsNullOrEmpty(ns))
        {
            buffer.Append(ns.Replace('.', '_'));
            buffer.Append('_');
        }

        buffer.Append(className);
        buffer.Append("_Accessor.g.cs");

        return buffer.ToString();
    }
}
