namespace MemberAccessorGenerator.SourceGenerator;

using System;
using System.Collections.Immutable;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator]
public sealed class MemberAccessorGenerator : IIncrementalGenerator
{
    // ------------------------------------------------------------
    // Generator
    // ------------------------------------------------------------

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var compilationProvider = context.CompilationProvider;
        var classes = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => IsTargetSyntax(node),
                static (context, _) => GetTargetSyntax(context))
            .SelectMany(static (x, _) => x is not null ? ImmutableArray.Create(x) : [])
            .Collect();

        var providers = compilationProvider.Combine(classes);

        context.RegisterImplementationSourceOutput(
            providers,
            static (spc, source) => Execute(spc, source.Left, source.Right));
    }

    private static bool IsTargetSyntax(SyntaxNode node) =>
        node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private static ClassDeclarationSyntax? GetTargetSyntax(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not ITypeSymbol typeSymbol)
        {
            return null;
        }

        var hasAttribute = typeSymbol.GetAttributes()
            .Any(static x => x.AttributeClass!.ToDisplayString() == "MemberAccessorGenerator.GenerateAccessorAttribute" &&
                             x.ConstructorArguments.Length == 0);
        if (!hasAttribute)
        {
            return null;
        }

        return classDeclarationSyntax;
    }

    // ------------------------------------------------------------
    // Builder
    // ------------------------------------------------------------

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes)
    {
        var filename = new StringBuilder();
        var source = new StringBuilder();
        var factories = new List<string>();

        GenerateAccessorFactories(context, compilation, classes, source, filename, factories);
        GenerateAccessorFactoryInitializer(context, source, filename, factories);
    }

    private static void GenerateAccessorFactories(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        StringBuilder source,
        StringBuilder filename,
        List<string> factories)
    {
        foreach (var classDeclarationSyntax in classes)
        {
            // Check cancel
            context.CancellationToken.ThrowIfCancellationRequested();

            // Build metadata
            var classSemantic = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            var classSymbol = (ITypeSymbol)classSemantic.GetDeclaredSymbol(classDeclarationSyntax)!;

            var ns = classSymbol.ContainingNamespace.IsGlobalNamespace
                ? string.Empty
                : classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;
            var factoryName = className + "_AccessorFactory";

            factories.Add(String.IsNullOrEmpty(ns) ? factoryName : $"{ns}.{factoryName}");

            var properties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(static x => x.DeclaredAccessibility is Accessibility.Internal or Accessibility.Public)
                .ToList();

            // Source
            source.AppendLine("// <auto-generated />");
            source.AppendLine("#nullable disable");

            // namespace
            if (!String.IsNullOrEmpty(ns))
            {
                source.Append("namespace ").Append(ns).AppendLine();
            }

            source.AppendLine("{");

            // class
            source.Append("    internal sealed class ");
            source.Append(factoryName);
            source.Append(" : IAccessorFactory<");
            source.Append(className);
            source.Append('>');
            source.AppendLine();
            source.AppendLine("    {");

            // object getter
            foreach (var property in properties)
            {
                source.Append("        private static readonly Func<object, object> ");
                AppendObjectGetter(source, property.Name);
                source.Append(" = x => ((");
                source.Append(className);
                source.Append(")x).");
                source.Append(property.Name);
                source.Append(';');
                source.AppendLine();
            }

            // object setter
            foreach (var property in properties)
            {
                source.Append("        private static readonly Action<object, object> ");
                AppendObjectSetter(source, property.Name);
                source.Append(" = (x, v) => ((");
                source.Append(className);
                source.Append(")x).");
                source.Append(property.Name);
                source.Append(" = (");
                source.Append(property.Type.ToDisplayString());
                source.Append(")v;");
                source.AppendLine();
            }

            // typed getter
            foreach (var property in properties)
            {
                source.Append("        private static readonly Func<");
                source.Append(className);
                source.Append(", ");
                source.Append(property.Type.ToDisplayString());
                source.Append("> ");
                AppendTypedGetter(source, property.Name);
                source.Append(" = x => x.");
                source.Append(property.Name);
                source.Append(';');
                source.AppendLine();
            }

            // typed setter
            foreach (var property in properties)
            {
                source.Append("        private static readonly Action<");
                source.Append(className);
                source.Append(", ");
                source.Append(property.Type.ToDisplayString());
                source.Append("> ");
                AppendTypedSetter(source, property.Name);
                source.Append(" = (x, v) => x.");
                source.Append(property.Name);
                source.Append(" = v;");
                source.AppendLine();
            }

            // create getter

            source.AppendLine();
            source.AppendLine("        public Func<object, object> CreateGetter(string name)");
            source.AppendLine("        {");
            foreach (var property in properties)
            {
                source.Append("            if (name == \"");
                source.Append(property.Name);
                source.Append("\") return ");
                AppendObjectGetter(source, property.Name);
                source.Append(';');
                source.AppendLine();
            }
            source.AppendLine("            return null;");
            source.AppendLine("        }");

            // create setter

            source.AppendLine();
            source.AppendLine("        public Action<object, object> CreateSetter(string name)");
            source.AppendLine("        {");
            foreach (var property in properties)
            {
                source.Append("            if (name == \"");
                source.Append(property.Name);
                source.Append("\") return ");
                AppendObjectSetter(source, property.Name);
                source.Append(';');
                source.AppendLine();
            }
            source.AppendLine("            return null;");
            source.AppendLine("        }");

            // create getter

            source.AppendLine();
            source.Append("        public Func<");
            source.Append(className);
            source.Append(", TProperty> CreateGetter<TProperty>(string name)");
            source.AppendLine();
            source.AppendLine("        {");
            foreach (var property in properties)
            {
                source.Append("            if (name == \"");
                source.Append(property.Name);
                source.Append("\") return (Func<");
                source.Append(className);
                source.Append(", TProperty>)(object)");
                AppendTypedGetter(source, property.Name);
                source.Append(';');
                source.AppendLine();
            }
            source.AppendLine("            return null;");
            source.AppendLine("        }");

            // create setter

            source.AppendLine();
            source.Append("        public Action<");
            source.Append(className);
            source.Append(", TProperty> CreateSetter<TProperty>(string name)");
            source.AppendLine();
            source.AppendLine("        {");
            foreach (var property in properties)
            {
                source.Append("            if (name == \"");
                source.Append(property.Name);
                source.Append("\") return (Action<");
                source.Append(className);
                source.Append(", TProperty>)(object)");

                AppendTypedSetter(source, property.Name);
                source.Append(';');
                source.AppendLine();
            }
            source.AppendLine("            return null;");
            source.AppendLine("        }");

            source.AppendLine("    }");
            source.AppendLine("}");

            // Write
            context.AddSource(
                MakeAccessorFilename(filename, ns, className),
                SourceText.From(source.ToString(), Encoding.UTF8));

            source.Clear();
        }
    }

    private static void AppendObjectGetter(StringBuilder sb, string name) =>
        sb.Append("Object").Append(name).Append("Getter");

    private static void AppendObjectSetter(StringBuilder sb, string name) =>
        sb.Append("Object").Append(name).Append("Setter");

    private static void AppendTypedGetter(StringBuilder sb, string name) =>
        sb.Append("Typed").Append(name).Append("Getter");

    private static void AppendTypedSetter(StringBuilder sb, string name) =>
        sb.Append("Typed").Append(name).Append("Setter");

    private static string MakeAccessorFilename(StringBuilder buffer, string ns, string className)
    {
        buffer.Clear();

        if (!String.IsNullOrEmpty(ns))
        {
            buffer.Append(ns.Replace('.', '_'));
            buffer.Append('_');
        }

        buffer.Append(className);
        buffer.Append("_Accessor.g.cs");

        return buffer.ToString();
    }

    private static void GenerateAccessorFactoryInitializer(
        SourceProductionContext context,
        StringBuilder source,
        StringBuilder filename,
        List<string> factories)
    {
        // Source
        source.AppendLine("// <auto-generated />");
        source.AppendLine("#nullable disable");

        source.AppendLine("internal static class AccessorFactoryInitializer");
        source.AppendLine("{");
        source.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        source.AppendLine("    public static void Initialize()");
        source.AppendLine("    {");

        foreach (var factory in factories)
        {
            source.Append("        MemberAccessorGenerator.AccessorRegistry.RegisterFactory(new ");
            source.Append(factory);
            source.Append("());");
            source.AppendLine();
        }

        source.AppendLine("    }");
        source.AppendLine("}");

        // Write
        context.AddSource(
            MakeInitializerFilename(filename),
            SourceText.From(source.ToString(), Encoding.UTF8));

        source.Clear();
    }

    private static string MakeInitializerFilename(StringBuilder buffer)
    {
        buffer.Clear();

        buffer.Append("AccessorInitializer.g.cs");

        return buffer.ToString();
    }
}
